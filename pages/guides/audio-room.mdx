---
title: 'Audio Rooms'
---

import { Callout, Steps, Tab, Tabs } from 'nextra-theme-docs';

# Building an Audio Room using the Huddle01 SDK

## Walkthrough

The following guide explains how you can integrate audio communication into your application seamlessly using Huddle01 SDKs.

<Steps>
### Installation


<Tabs items={['React', 'Flutter']}>
  <Tab>
    **Install `@huddle01/react` in your react app**

    To power your React DApp with audio communication using Huddle01 install the following:

    <Tabs items={['pnpm', 'npm', 'yarn']}>
      <Tab>
        ```bash 
          pnpm i @huddle01/react 
        ```
      </Tab>
      <Tab>
        ```bash 
        npm i @huddle01/react 
        ```
      </Tab>
      <Tab>
        ```bash 
        yarn add @huddle01/react 
        ```
      </Tab>
    </Tabs>
  </Tab>
  <Tab>
    **Install `huddle01_flutter_client` in your flutter app**

    To power your Flutter DApp with audio communication using Huddle01 install the following:

    ```bash 
      flutter pub add huddle01_flutter_client
    ```
  </Tab>
</Tabs>

### Initialization of project

<Tabs items={['React', 'Flutter']}>
  <Tab>
  {/* TODO: Add initialization of project link */}
  Head over to [API Keys Page](/api-keys) and connect your wallet to get your project credentials: 

  - `API Key`
  - `projectId`

  Once done, initialize your project by calling the `initialize()` method and pass `projectId`  in params. 


  ```tsx filename="app.tsx"
  import { useHuddle01 } from '@huddle01/react';

  const App = () => {
    const { initialize, isInitialized } = useHuddle01();

    useEffect(() => {
      // its preferable to use env vars to store projectId
      initialize('YOUR_PROJECT_ID');
    }, []);

    return <div>{isInitialized ? 'Hello World!' : 'Please initialize'}</div>;
  };
  ```
  </Tab>
 <Tab>
  Head over to [API Keys Page](/api-keys) and connect your wallet to get your project credentials: 

  - `API Key`
  - `projectId`

  Once done, initialize your project by calling the `initialize()` method and pass `projectId`  in params. 


  ```tsx filename="app.dart"
  String projectId = 'YOUR-PROJECT-ID';
  String roomId = 'YOUR-ROOM-ID';

  // Initialize your huddleClient 
  HuddleClient huddleClient = HuddleClient();

  // Initialize project
  huddleClient.initialize(projectId);
  ```
  </Tab>
</Tabs>


### Joining the lobby

Room Id can be generated using the : [Create Room API](/apis/create-room/create-room)

<Tabs items={['React', 'Flutter']}>
  <Tab>

  Add the following button to your jsx and call the `joinLobby()` method.

  ```tsx filename="app.tsx" highlight={2,7,16-21}
    import { useHuddle01 } from '@huddle01/react';
    import { useLobby } from '@huddle01/react/hooks';


    const App = () => {
      const { initialize, isInitialized } = useHuddle01();
      const { joinLobby } = useLobby();

      useEffect(() => {
        // its preferable to use env vars to store projectId
        initialize('YOUR_PROJECT_ID');
      }, []);
    
      return (
        <div>{isInitialized ? 'Hello World!' : 'Please initialize'}
          <button 
            disabled={joinLobby.isCallable} 
            onClick={() => joinLobby('YOUR_ROOM_ID');
          }>
            Join Lobby
          </button>
        </div>
      );
    };
  ```


  <Callout type="info">
    The **`isCallable`** is an attribute available on all methods to check whether the function is callable or not.
  </Callout>

    Room creation using the [Create Room API](/apis/create-room/create-room) can be done in the following ways:
    <details>
      <summary>
        NextJs API Route to create room  (NodeJs)
      </summary>

      This is how you can create a room using [NextJS API Route](https://nextjs.org/docs/api-routes/introduction) and pass the `roomId` to the `joinLobby()` method.

      ```ts filename="pages/api/create-room.ts" 
      import axios from 'axios';

      import type { NextApiRequest, NextApiResponse } from 'next';

      const handler = async (req: NextApiRequest, res: NextApiResponse) => {
        try {
          const { data } = await axios.post(
            'https://api.huddle01.com/api/v1/create-room',
            {
              title: 'Huddle01-Test',
              roomLock: false,
            },
            {
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.API_KEY,
              },
            }
          );

          res.status(200).json(data);
        } catch (error) {
          res.status(500).json(error);
        }
      };

      export default handler;
      ```
    </details>

    <details>
      <summary>
        NextJS `getServerSideProps()` room creation example
      </summary>
      This is how you can create a room using [getServerSideProps()](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props) and pass the `roomId` to the `joinLobby()` method.

      ```tsx filename="app.tsx" 
      export const getServerSideProps: GetServerSideProps<{
        roomId: string;
      }> = async () => {
        const { data } = await axios.post(
          'https://api.huddle01.com/api/v1/create-room',
          {
            title: 'Huddle01-SDK-Test',
            roomLock: false,
          },
          {
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': process.env.API_KEY,
            },
          }
        );

        return {
          props: {
            roomId: data.roomId,
          },
        };
      };
      ```
    </details>
  </Tab>

  <Tab>
    Add the following `TextButton` to your jsx and call the `joinLobby()` method.

    ```dart
      import 'package:flutter/material.dart';
import 'package:huddle01_flutter_client/huddle_client.dart';

      class MeetingScreen extends StatefulWidget {
        const MeetingScreen({super.key});

        @override
        State<MeetingScreen> createState() => _MeetingScreenState();
      }

      class _MeetingScreenState extends State<MeetingScreen> {
        HuddleClient huddleClient = HuddleClient();
        String roomId = 'MY-ROOM-ID';
        @override
        Widget build(BuildContext context) {
          return Scaffold(
            appBar: AppBar(
              title: const Text("My Meeting App"),
            ),
            body: Column(children: [
              TextButton(
                child: const Text('JOIN-LOBBY'),
                onPressed: () {
                  if (huddleClient.isJoinLobbyCallable()) {
                    huddleClient.joinLobby(roomId);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('JOIN-LOBBY -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              ),
            ]),
          );
        }
      }
    ```
  </Tab>


</Tabs >

### Enabling and Disabling Media Devices

<Tabs items={['React', 'Flutter']}>
  <Tab>
    ```tsx filename="app.tsx" highlight={2,8-9,26-28}
    import { useHuddle01 } from '@huddle01/react';
    import { useLobby, useAudio } from '@huddle01/react/hooks';


    const App = () => {
      const { initialize, isInitialized } = useHuddle01();
      const { joinLobby } = useLobby();
      const { fetchAudioStream, stopAudioStream, error: micError } = useAudio();
      // Show error if it exists

      useEffect(() => {
        // its preferable to use env vars to store projectId
        initialize('YOUR_PROJECT_ID');
      }, []);
    
      return (
        <div>{isInitialized ? 'Hello World!' : 'Please initialize'}
          <button 
            disabled={joinLobby.isCallable} 
            onClick={() => joinLobby('YOUR_ROOM_ID');
          }>
            Join Lobby
          </button>

        {/* Mic */} 
          <button disabled={!fetchAudioStream.isCallable} onClick={fetchAudioStream}>
            FETCH_AUDIO_STREAM
          </button>

        </div>
      );
    };
    ```

    <Callout type="info">
      The **`isCallable`** is an attribute available on all methods to check whether the function is callable or not.
    </Callout>

  </Tab>
  <Tab>
    ```dart filename="app.dart"
      import 'package:flutter/material.dart';
import 'package:huddle01_flutter_client/huddle_client.dart';

      class MeetingScreen extends StatefulWidget {
        const MeetingScreen({super.key});

        @override
        State<MeetingScreen> createState() => _MeetingScreenState();
      }

      class _MeetingScreenState extends State<MeetingScreen> {
        HuddleClient huddleClient = HuddleClient();
        String roomId = 'MY-ROOM-ID';
        @override
        Widget build(BuildContext context) {
          return Scaffold(
            appBar: AppBar(
              title: const Text("My Meeting App"),
            ),
            body: Column(children: [
              TextButton(
                child: const Text('JOIN-LOBBY'),
                onPressed: () {
                  if (huddleClient.isJoinLobbyCallable()) {
                    huddleClient.joinLobby(roomId);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('JOIN-LOBBY -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              ),
              TextButton(
                child: const Text('FETCH-AUDIO'),
                onPressed: () {
                  if (huddleClient.isFetchAudioStreamCallable()) {
                    huddleClient.fetchAudioStream();
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('FETCH-AUDIO -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              ),
            ]),
          );
        }
      }
    ```
  </Tab>

</Tabs>



### Joining and leaving the room

Add the `joinRoom()` and `leaveRoom()` methods for joining and leaving functionalities.
The joinRoom() method can be called to enter the room, once the lobby has been joined. To leave that respective room you can call the leaveRoom() method in the ROOM state.

<Tabs items={['React', 'Flutter']}>
  <Tab>


  ```tsx filename="app.tsx" highlight={2,9,36-42}
    import { useHuddle01 } from '@huddle01/react';
    import { useLobby, useAudio, useVideo, useRoom } from '@huddle01/react/hooks';

    const App = () => {
      const { initialize, isInitialized } = useHuddle01();
      const { joinLobby } = useLobby();
      const { fetchAudioStream, stopAudioStream, error: micError } = useAudio();
      const { fetchVideoStream, stopVideoStream, error: camError } = useVideo(); 
      const { joinRoom, leaveRoom } = useRoom();


      useEffect(() => {
        // its preferable to use env vars to store projectId
        initialize('YOUR_PROJECT_ID');
      }, []);
    
      return (
        <div>{isInitialized ? 'Hello World!' : 'Please initialize'}
          <button 
            disabled={joinLobby.isCallable} 
            onClick={() => joinLobby('YOUR_ROOM_ID');
          }>
            Join Lobby
          </button>

          {/* Mic */} 
          <button disabled={!fetchAudioStream.isCallable} onClick={fetchAudioStream}>
            FETCH_AUDIO_STREAM
          </button>

          {/* Webcam */} 
          <button disabled={!fetchVideoStream.isCallable} onClick={fetchVideoStream}>
            FETCH_VIDEO_STREAM
          </button>

          <button disabled={!joinRoom.isCallable} onClick={joinRoom}>
            JOIN_ROOM 
          </button>

          <button disabled={!leaveRoom.isCallable} onClick={leaveRoom}>
            LEAVE_ROOM 
          </button>
        </div>
      );
    };

  ```

  <Callout type="info">
  The **`isCallable`** is an attribute available on all methods to check whether the function is callable or not.
</Callout>
  </Tab>
  <Tab>


  ```dart filename="app.dart" 
    import 'package:flutter/material.dart';
import 'package:huddle01_flutter_client/huddle_client.dart';

      class MeetingScreen extends StatefulWidget {
        const MeetingScreen({super.key});

        @override
        State<MeetingScreen> createState() => _MeetingScreenState();
      }

      class _MeetingScreenState extends State<MeetingScreen> {
        HuddleClient huddleClient = HuddleClient();
        String roomId = 'MY-ROOM-ID';
        @override
        Widget build(BuildContext context) {
          return Scaffold(
            appBar: AppBar(
              title: const Text("My Meeting App"),
            ),
            body: Column(children: [
              TextButton(
                child: const Text('JOIN-LOBBY'),
                onPressed: () {
                  if (huddleClient.isJoinLobbyCallable()) {
                    huddleClient.joinLobby(roomId);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('JOIN-LOBBY -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              ),
              TextButton(
                child: const Text('FETCH-AUDIO'),
                onPressed: () {
                  if (huddleClient.isFetchAudioStreamCallable()) {
                    huddleClient.fetchAudioStream();
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('FETCH-AUDIO -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              TextButton(
                child: const Text('JOIN-ROOM'),
                onPressed: () {
                    huddleClient.joinRoom(roomId);
                },
              ),
              TextButton(
                child: const Text('LEAVE-ROOM'),
                onPressed: () {
                    huddleClient.leaveRoom();
                },
              ),
            ]),
          );
        }
      }

  ```
  </Tab>

</Tabs>

<Callout type="info">
Clicking on the **JOIN_ROOM** button, will make the user join the room and will allow them to send/receive media with other participants.
</Callout>

### Sending media across to other participants
Here, we are using a term **PRODUCE** which means sending your audio/video stream across to the other peer who will **CONSUME** (or receive) the streams.

<Tabs items={['React', 'Flutter']}>
  <Tab>
    ```tsx filename="app.tsx" highlight={9,14,51-65}
      import { useHuddle01 } from '@huddle01/react';
      import { useLobby, useAudio, useVideo, useRoom } from '@huddle01/react/hooks';

      const App = () => {
        const { initialize, isInitialized } = useHuddle01();
        const { joinLobby } = useLobby();
        const { 
          fetchAudioStream, stopAudioStream, error: micError, 
          produceAudio, stopProducingAudio 
        } = useAudio();

        const { 
          fetchVideoStream, stopVideoStream, error: camError, 
          produceVideo, stopProducingVideo 
        } = useVideo(); 
        const { joinRoom, leaveRoom } = useRoom();


        useEffect(() => {
          // its preferable to use env vars to store projectId
          initialize('YOUR_PROJECT_ID');
        }, []);
      
        return (
          <div>{isInitialized ? 'Hello World!' : 'Please initialize'}
            <button 
              disabled={joinLobby.isCallable} 
              onClick={() => joinLobby('YOUR_ROOM_ID')} >
              Join Lobby
            </button>

            {/* Mic */} 
            <button disabled={!fetchAudioStream.isCallable} onClick={fetchAudioStream}>
              FETCH_AUDIO_STREAM
            </button>

            {/* Webcam */} 
            <button disabled={!fetchVideoStream.isCallable} onClick={fetchVideoStream}>
              FETCH_VIDEO_STREAM
            </button>

            <button disabled={!joinRoom.isCallable} onClick={joinRoom}>
              JOIN_ROOM 
            </button>

            <button disabled={!leaveRoom.isCallable} onClick={leaveRoom}>
              LEAVE_ROOM 
            </button>

            <button disabled={!produceVideo.isCallable} onClick={() => produceVideo(camStream)}>
              Produce Cam  
            </button>

            <button disabled={!produceAudio.isCallable} onClick={() => produceAudio(micStream)}>
              Produce Mic  
            </button>

            <button disabled={!stopProducingVideo.isCallable} onClick={stopProducingVideo}>
              Stop Producing Cam  
            </button>

            <button disabled={!stopProducingAudio.isCallable} onClick={stopProducingAudio}>
              Stop Producing Mic  
            </button>

          </div>
        );
      };

    ```
  </Tab>
  <Tab>
    ```dart filename="app.dart"
    import 'package:flutter/material.dart';
    import 'package:huddle01_flutter_client/huddle_client.dart';

      class MeetingScreen extends StatefulWidget {
        const MeetingScreen({super.key});

        @override
        State<MeetingScreen> createState() => _MeetingScreenState();
      }

      class _MeetingScreenState extends State<MeetingScreen> {
        HuddleClient huddleClient = HuddleClient();
        String roomId = 'MY-ROOM-ID';
        @override
        Widget build(BuildContext context) {
          return Scaffold(
            appBar: AppBar(
              title: const Text("My Meeting App"),
            ),
            body: Column(children: [
              TextButton(
                child: const Text('JOIN-LOBBY'),
                onPressed: () {
                  if (huddleClient.isJoinLobbyCallable()) {
                    huddleClient.joinLobby(roomId);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('JOIN-LOBBY -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              ),
              TextButton(
                child: const Text('FETCH-AUDIO'),
                onPressed: () {
                  if (huddleClient.isFetchAudioStreamCallable()) {
                    huddleClient.fetchAudioStream();
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content: Text('FETCH-AUDIO -> not callable yet'),
                      backgroundColor: Colors.red,
                      elevation: 4,
                      behavior: SnackBarBehavior.floating,
                      margin: EdgeInsets.all(5),
                      duration: Duration(seconds: 1),
                    ));
                  }
                },
              TextButton(
                child: const Text('JOIN-ROOM'),
                onPressed: () {
                    huddleClient.joinRoom(roomId);
                },
              ),
              TextButton(
                child: const Text('LEAVE-ROOM'),
                onPressed: () {
                    huddleClient.leaveRoom();
                },
              ),
              TextButton(
                child: const Text('PRODUCE_AUDIO'),
                onPressed: () {
                    huddleClient.produceAudio(stream);
                },
              ),
              TextButton(
                child: const Text('STOP-PRODUCING-AUDIO'),
                onPressed: () {
                    huddleClient.stopProducingAudio();
                },
              ),
            ]),
          );
        }
      }
    ```
  </Tab>


</Tabs>


### Receiving the audio and video streams
Here, we are using a term **PRODUCE** which means sending your audio/video stream across to the other peer who will **CONSUME** (or receive) the streams.


<Tabs items={['React', 'Flutter']}>

  <Tab>

    <details>
      <summary>
        Getting access to data related to peers
      </summary>
      JSX:
      ```tsx
      import { usePeers } from '@huddle01/react/hooks';

      export default function() {
        const peers = usePeers();
        
        return <div>{JSON.stringify(peers)}</div>
      }

      ```
      Output: (Example Output for 1 peer)
      ```json
      [
        {
          peerId: "sdksjdsjd",
          mic: MediaStreamTrack,
          cam: MediaStreamTrack
        }
      ]

      ```
    </details>

    <details>
      <summary>
        Using the audio and video tags
      </summary>

        Importing the Audio and Video tags:

        ```tsx
        // importing
        import { Video, Audio } from '@huddle01/react/components'
        ```

        There are three ways to use the audio and video tags
        #### 1. Using `peerId` :

        ```tsx  
          <Video peerId="PEER_ID" />
          <Audio peerId="PEER_ID" />
        ```
        #### 2. Using `track` or `stream` : 

        <Callout type="info">
          The **`stream`** value for **mic** and **cam** are available on the **`useAudio`** and **`useVideo`** hooks respectively.
        </Callout>
        <Callout type="info">
          The **`tracks`** for peers can be found from the **`usePeers`** hook.
        </Callout>


        <Callout emoji="ðŸš¨">
          To be used only when you want to make changes to streams from your side otherwise use `peerId` method!
        </Callout>


        ```tsx
          <Video peerId="PEER_ID" track={camTrack}  />
          <Audio peerId="PEER_ID" track={micTrack} />
        ```

        ```tsx
          <Video peerId="PEER_ID" stream={camStream}  />
          <Audio peerId="PEER_ID" stream={micStream} />
        ```
    </details>




    The video and audio streams for the peers can be accessed using the **`usePeers`** hook. The **`usePeers`** hook returns an array of objects with the following structure:

    ```json
    [
      {
        peerId: "sdksjdsjd",
        mic: MediaStreamTrack,
        cam: MediaStreamTrack
      }
    ]

    ```

    The **`peerId`** is the unique identifier for the peer. The **`mic`** and **`cam`** are the **`MediaStreamTrack`** objects for the audio and video streams respectively.

    The **`usePeers`** hook can be used to access the audio and video streams for the peers and can be used in the following way to render the audio and video streams:

    ```tsx filename="app.tsx" highlight={18,28-36}
      import { useHuddle01 } from '@huddle01/react';
      import { useLobby, useAudio, useVideo, useRoom } from '@huddle01/react/hooks';

      const App = () => {
        const { initialize, isInitialized } = useHuddle01();
        const { joinLobby } = useLobby();
        const { 
          fetchAudioStream, stopAudioStream, error: micError, 
          produceAudio, stopProducingAudio 
        } = useAudio();

        const { 
          fetchVideoStream, stopVideoStream, error: camError, 
          produceVideo, stopProducingVideo 
        } = useVideo(); 
        const { joinRoom, leaveRoom } = useRoom();

        const { peerIds } = usePeers();

        useEffect(() => {
          // its preferable to use env vars to store projectId
          initialize('YOUR_PROJECT_ID');
        }, []);
      
        return (
          <div>{isInitialized ? 'Hello World!' : 'Please initialize'}

            <div className="grid grid-cols-4">
              {peerIds.map(peerId => (
                  <Video key={peer.peerId} peerId={peer.peerId} debug />
              ))}

              {peerIds.map(peerId => (
                  <Audio key={peer.peerId} peerId={peer.peerId} debug />
              ))}
            </div>

            <button 
              disabled={joinLobby.isCallable} 
              onClick={() => joinLobby('YOUR_ROOM_ID');
            }>
              Join Lobby
            </button>

            {/* Mic */} 
            <button disabled={!fetchAudioStream.isCallable} onClick={fetchAudioStream}>
              FETCH_AUDIO_STREAM
            </button>

            {/* Webcam */} 
            <button disabled={!fetchVideoStream.isCallable} onClick={fetchVideoStream}>
              FETCH_VIDEO_STREAM
            </button>

            <button disabled={!joinRoom.isCallable} onClick={joinRoom}>
              JOIN_ROOM 
            </button>

            <button disabled={!leaveRoom.isCallable} onClick={leaveRoom}>
              LEAVE_ROOM 
            </button>

            <button disabled={!produceVideo.isCallable} onClick={() => produceVideo(camStream)}>
              Produce Cam  
            </button>

            <button disabled={!produceAudio.isCallable} onClick={() => produceAudio(micStream)}>
              Produce Mic  
            </button>

            <button disabled={!stopProducingVideo.isCallable} onClick={stopProducingVideo}>
              Stop Producing Cam  
            </button>

            <button disabled={!stopProducingAudio.isCallable} onClick={stopProducingAudio}>
              Stop Producing Mic  
            </button>

          </div>
        );
      };

    ```

    ### You're all set! Happy Hacking! ðŸŽ‰

    For more information, please refer to the [SDK Reference](/React).


  </Tab>
  <Tab>
  <details>
    <summary>
      Getting access to remote video/audio streams
    </summary>
    JSX:
    ```dart
    // remote-stream
    RTCVideoRenderer? remoteRenderer;
    initilialize() async {
      remoteRenderer = RTCVideoRenderer();
      await remoteRenderer!.initialize();
      remoteRenderer!.srcObject = huddleClient.getRemoteStream();
    }
    ```
  </details>


```dart filename="app.dart" 
  const Text(
              "Local Stream",
              style: TextStyle(fontSize: 18),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(25, 0, 25, 0),
              child: Container(
                  color: Colors.grey,
                  width: 500,
                  height: 250,
                  child: huddleClient.getRenderer() != null
                      ? RTCVideoView(
                          huddleClient.getRenderer()!,
                          objectFit:
                              RTCVideoViewObjectFit.RTCVideoViewObjectFitCover,
                        )
                      : null),
            ),
            TextButton(
              child: const Text(
                'Get Remote Stream',
                style: TextStyle(fontSize: 18),
              ),
              onPressed: () {
                initilialize();
              },
            ),
          
            Padding(
              padding: const EdgeInsets.fromLTRB(25, 0, 25, 0),
              child: Container(
                  color: Colors.grey,
                  width: 500,
                  height: 250,
                  child: huddleClient.getConsumers().isNotEmpty
                      ? RTCVideoView(
                          remoteRenderer!,
                          objectFit:
                              RTCVideoViewObjectFit.RTCVideoViewObjectFitCover,
                        )
                      : null),
            ),

```

### You're all set! Happy Hacking! ðŸŽ‰

For more information, please refer to the [SDK Reference](/Flutter).


  </Tab>

</Tabs>


</Steps>
